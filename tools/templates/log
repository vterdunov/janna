//go:generate go run github.com/hexdigest/gowrap/cmd/gowrap gen -g -p github.com/vterdunov/janna-proto/gen/go/v1 -i JannaAPIServer -t ../../../../tools/templates/log -o logging_gen.go

import (
	context "context"
	"time"

	_ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
	"github.com/pkg/errors"
	"github.com/vterdunov/janna/internal/log"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"

  apiv1 "github.com/vterdunov/janna-proto/gen/go/v1"
)


{{ $decorator := (or .Vars.DecoratorName (printf "%sWithLog" .Interface.Name)) }}

// {{$decorator}} implements {{.Interface.Type}} that is instrumented with logrus logger
type {{$decorator}} struct {
  logger log.Logger
  next {{.Interface.Type}}
}

// New{{$decorator}} instruments an implementation of the {{.Interface.Type}} with simple logging
func New{{$decorator}}(next {{.Interface.Type}}, logger log.Logger) {{$decorator}} {
  return {{$decorator}}{
    next: next,
    logger: logger,
  }
}

{{range $method := .Interface.Methods}}
  // {{$method.Name}} implements {{$.Interface.Type}}
  func (m {{$decorator}}) {{$method.Declaration}} {
      {{- if $method.HasParams}}
        begin := time.Now()
        logger := withRequestID(ctx, m.logger)
        logger = logger.WithFields(
          "method", "{{$method.Name}}",
        )

        logger.Info("calling endpoint")

        res, err := m.next.{{$method.Name}}({{$method.ParamsNames}})

      {{else}}
      {{end -}}
      defer func(begin time.Time) {
        {{- if $method.HasResults}}
          logger = logger.WithFields(
            "took", time.Since(begin).String(),
          )

          {{- if $method.ReturnsError}}
            if err != nil {
              logger.Error(err, "call failed")
            } else {
              logger.Info("call successful")
            }
          {{else}}
            logger.Info("call successful")
          {{end -}}
        {{else}}
          logger.Info("call successful")
        {{end -}}
      }(begin)

      return res, translateError(err)
  }
{{end}}


func withRequestID(ctx context.Context, logger log.Logger) log.Logger {
	reqID := ""
	if md, ok := metadata.FromIncomingContext(ctx); ok {
		if len(md["request_id"]) > 0 {
			reqID = md["request_id"][0]
		}
	}

	l := logger.WithFields(
		"request_id", reqID,
	)

	return l
}

type statusError interface {
	GRPCStatus() *status.Status
}

func isGrpcStatusError(err error) bool {
	_, ok := err.(statusError)
	return ok
}

// translateError translate business logic erros to transport level errors.
// May become clumsy because of the need to check all exposed errors
// from all packages with business logic.
func translateError(err error) error {
	if err == nil {
		return nil
	}

	if isGrpcStatusError(err) {
		return err
	}

	switch errors.Cause(err) {
	// case producer.ErrVMAlreadyExist:
	// 	err = status.Errorf(codes.AlreadyExists, err.Error())
	default:
		err = status.Errorf(codes.Internal, err.Error())
	}

	return err
}
